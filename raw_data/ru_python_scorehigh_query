Как из скрипта на Питоне послать письмо с вложением?	Нужен простейший пример посылки письма с вложением через внешний SMTP сервер, например, smtp.yandex.ru.	python|smtp	27
IDE для Python	Среды разработки и текстовые редакторы для разработки на Python. Их плюсы и минусы.	python|ide	14
Отладка кода на Питоне	Имеется проект написанный на Питоне. Я разрабатываю его на платформе Убунту, в текстовом редакторе. Какими средствами надо воспользоваться, чтобы получить возможность пошаговой отладки?	python|ubuntu|отладка	10
Нейронные сети на Python	Кто сталкивался? Какие библиотеки посоветуете? Есть ли примеры работы у кого-нибудь?&#xA;	python|нейронные-сети|машинное-обучение	9
Нейронные сети на Python для &quot;чайника&quot;	Часто встречаю такое понятие, как нейронные сети и, учитывая еще и тот факт, что потихоньку изучаю Python, то возникла потребность &quot;что-то эдакое&quot; попробовать самому написать, но более менее встречающаяся литература в сети, слишком &quot;тверда и не по зубам&quot; для меня. А ведь так захватывающе - попробовать!&#xA;Вопрос: есть ли ресурс, где есть простенькие примеры на Python, для &quot;блондинки с чайником в руках&quot;? В общем буду признателен всем, кто может посодействовать.	python|книги|нейронные-сети	9
Python imports	Добрый день!&#xA;Используя конструкцию вида:&#xA;&lt;pre&gt;&lt;code&gt;from a import *&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;Но не используя все классы/функции и т.п. из &lt;code&gt;a&lt;/code&gt;, можно ли сказать, что это влияет на скорость работы программы, на количество требующейся памяти? Или для python это не страшно?	python	12
Будущие перспективы программирования?	Здравствуйте, уважаемые. &#xA;Дело в том, что находясь на 2 курсе Информационных технологий наступает такая пора, когда надо выбирать дальнейшее направление в мире программирования. А именно между Web-Dev и прикладным программированием, к тому же выбор ЯП как основново инструмента. &#xA;В институте ”проходим” &lt;strong&gt;&lt;em&gt;C++&lt;/em&gt;&lt;/strong&gt;, (хотя у меня язык не поворачивается назвать изучаем, скорее просто просматриваем логические и операторы вывода, старый синтаксис и т. д) и так целый семестр, складывается впечатление, что лектор отстает от жизни лет на 10 как минимум, и ничего нам больше не светит кроме нудной писанины математических функций в тетрадке. Тут же состоялось мое первое знакомство  с прикладным программированием, оставило довольно позитивное впечатление. &#xA;На &lt;strong&gt;3&lt;/strong&gt; курсе &lt;strong&gt;Java&lt;/strong&gt;, но уже страшно представить что будет с таким отношением к предмету со стороны лекторов...  Но это не главное,  мой университет считается &lt;em&gt;&quot;лучшим&quot;&lt;/em&gt; по &lt;em&gt;Самообразованию&lt;/em&gt;)  и на него я не расчитываю, только диплом.)&#xA;&lt;hr&gt;&#xA;К тому же,  я полтора года занимаюсь Веб-программированием и знаю (&lt;strong&gt;HTML&lt;/strong&gt;, &lt;strong&gt;CSS&lt;/strong&gt;, &lt;strong&gt;PHP&lt;/strong&gt;(средне), &lt;strong&gt;MySQL&lt;/strong&gt;), и до этого времени все шло замечательно, думал учиться на веб-программиста, пока я не задумался о будущем, а переспективно ли это, ведь мне придется выбрать одно направление и несколько инструментов для реализации, которые будут сопровождать меня всю жизнь... &#xA;И пошло поехало, стал взвешивать шансы, сравнивать графики ЯП за последние 7 лет, искать те или иные преимущества веб и прикладного программирования, лихорадочно бродить по гуглу выискивая задатки перспектив... &#xA;&lt;hr&gt;&#xA;Условно разделив ЯП на категории для достижения цели получил довольно интересную картину:&#xA;&lt;strong&gt;Веб-Программирование:&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;HTML/CSS/XML &lt;/li&gt;&#xA;&lt;li&gt;PHP + MySQL&lt;/li&gt;&#xA;&lt;li&gt;JavaScript&lt;/li&gt;&#xA;&lt;li&gt;Python + Django&lt;/li&gt;&#xA;&lt;li&gt;Ruby + RoR&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;strong&gt;Прикладное программирование:&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Java&lt;/li&gt;&#xA;&lt;li&gt;C#&lt;/li&gt;&#xA;&lt;li&gt;C++&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;Поиски документации по ЯП завели меня еще дальше, теперь выбор будущего стал более неопределенным. С одной строны &lt;strong&gt;Java&lt;/strong&gt; – всегда вакантные места и кроссплатформенность, к тому же несколько лет он занимает первые места в рейтинге и даже не намерен уступать. &#xA;&lt;strong&gt;C#&lt;/strong&gt; - за последнее время этот язык поддерживаемый Microsoft вырос на глазах, и продолжает расти, появляються перспективы полностью заменить C++. Язык будущего, но есть один большой минус, он зависим от платформ, а точнее от Windows... &#xA;&lt;strong&gt;C++&lt;/strong&gt; - постепенно умирающий язык. &lt;em&gt;ИМХО&lt;/em&gt;. Но его нельзя списывать со счетов. &#xA;&lt;hr&gt;&#xA;С другой стороны это Web-программирование которое немного ближе ко мне. &#xA;&lt;hr&gt;&#xA;&lt;strong&gt;PHP&lt;/strong&gt; – это первый мой ЯП который я считал довольно хорошим и перспективным, пока не познакомился с &lt;strong&gt;Python&lt;/strong&gt;, который очень впечатлил меня своей краткостью, гибкостью и конкурентоспособностью. Конечно популярностью PHP  мог бы позавидовать любой язык. В данный момент популярность начинает спадать, но вакансий как и в случае с Java не становиться меньше, а даже увеличивается. &#xA;&lt;strong&gt;Python&lt;/strong&gt; – все началось наверно с него, он перевернул мое представление о программировании, впечатляющий, лаконичный, легкий, строго типизированый, имеет очень много достоинств. В связке в &lt;strong&gt;Django&lt;/strong&gt; может обвести вокруг пальца любого конкурента, но есть существенный минус, это мало вакансий в моей стране. &#xA;&lt;hr&gt;&#xA;Впечетленным всем этим уже несколько неделей &lt;em&gt;страдаю фигней&lt;/em&gt;, а точнее определяю свое будущее и переспективы. &#xA;Если я уйду в &lt;strong&gt;Web&lt;/strong&gt;-разработку(а именно в Python, PHP, Ruby, Js) не прогадаю ли я?&#xA;Или, возможно сразу переквалифицироваться в Java или C#, я конечно понимаю, все зависит от человека?&#xA;Интересно ваше мнение. &#xA;&lt;hr&gt;&#xA;P. S Сорри за столь сумбурный монолог и за грамматические ошибки если такие имеются. 	php|java|c#|python	19
Как удалить значение из словаря во время цикла for	Как-то неожиданно столкнулся с такой проблемой. Во время цикла &lt;code&gt;for&lt;/code&gt; по словарю мне нужно удалять из него записи, но как не крути вылазит ошибка :&#xA;&lt;pre&gt;&lt;code&gt;RuntimeError: dictionary changed size during iteration&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;Я даже пробовал делать снапшот словаря перед итерацией и итерировать двойника при этом удаляя из оригинала.&#xA;Пример:&#xA;&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; ot={12:'wqe',13:'wqe',14:'wqe',15:'wqe'}&#xA;&amp;gt;&amp;gt;&amp;gt; ot1=ot&#xA;&amp;gt;&amp;gt;&amp;gt; for i in ot1:&#xA;...  del ot[i]&#xA;... &#xA;Traceback (most recent call last):&#xA;  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;&#xA;RuntimeError: dictionary changed size during iteration&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;Как удалять правильно?&#xA;upd:&#xA;разобрался, &#xA;снапшот был уместен, но сделан чуть чуть неправильно&#xA;вот так правильно:&#xA;&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; ot={12:'wqe',13:'wqe',14:'wqe',15:'wqe'}&#xA;&amp;gt;&amp;gt;&amp;gt; ot1=ot.copy()&#xA;&amp;gt;&amp;gt;&amp;gt; for i in ot1:&#xA;...  del ot[i]&#xA;&lt;/code&gt;&lt;/pre&gt;	python|циклы	9
Надежная изоляция без копирования бинарника Python или отмена эффектов site.py	Читаю &lt;a href=&quot;http://www.python.org/dev/peps/pep-0405/&quot;&gt;PEP 0405&lt;/a&gt; и вижу вот такую фразу:&#xA;&lt;blockquote&gt;&#xA;Tools such as rvirtualenv, which do not copy the Python binary into the virtual environment, cannot provide reliable isolation from system site directories.&#xA;&lt;/blockquote&gt;&#xA;Весь гугль измучал, рассылки почитал, но но не могу найти почему cannot provide.&#xA;Казалось бы, для надежной изоляции, должно быть достаточно:&#xA;&lt;ul&gt;&#xA;&lt;li&gt;вернуть в ванильное состояние переменных в &lt;code&gt;sys&lt;/code&gt;; в частности, в &lt;code&gt;sys.path&lt;/code&gt; восстановить из &lt;code&gt;Py_GetPath&lt;/code&gt; и вычистить &lt;code&gt;sys.modules&lt;/code&gt; от всего, что теперь не в нем;&lt;/li&gt;&#xA;&lt;li&gt;проверить целостность &lt;code&gt;__import__&lt;/code&gt;, в случае чего, восстановив через &lt;code&gt;builtin___import__&lt;/code&gt; (или &lt;code&gt;PyImport_ImportModuleLevel&lt;/code&gt;);&lt;/li&gt;&#xA;&lt;li&gt;пробежать по &lt;code&gt;sys.modules&lt;/code&gt;, проверив их нетронутость, а если что-то нарушено — нещадно перегрузить. Или даже просто перегрузить, не заморачиваясь каким-то анализом — простое друг надежного.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;Да, действия не самые тривиальные, но как-то не верится, что нельзя привести интерпретатор к ванильному состоянию, нейтрализовав эффекты &lt;code&gt;site&lt;/code&gt;/&lt;code&gt;sitecustomize&lt;/code&gt;/&lt;code&gt;usercustomize&lt;/code&gt;. Все же есть под капотом, libpython все что нужно экспортирует, бери да переинициализируй интерпретатор. (Да, это повышает время запуска, я знаю, спасибо, временно проигнорируем этот аспект.)&#xA;Что я упускаю из вида?	python|инициализация|virtualenv|интерпретатор	10
Как из Python вывести на Windows-консоль строку в Юникоде?	Простой print() не срабатывает. Интерпретатор валится с жалобой на то, что он сам не может сконвертировать Юникод в ту кодировку, которая используется в Windows-консоли. Может быть ему можно как-то помочь? Возможно, есть какой-нибудь модуль, который умеет это делать.	python|windows|кодировка|консоль|unicode	11
Python обработчик системного меню Windows	Всем привет.&#xA;Подскажите, пожалуйста, как в python перехватить событие нажатия на системное меню windows (то что в заголовке окна).&#xA;Добавляю в меню свой пункт так:&#xA;&lt;pre&gt;&lt;code&gt;hwnd = win32gui.GetForegroundWindow()&#xA;hmenu = win32gui.GetSystemMenu (hwnd, False)&#xA;win32gui.AppendMenu (hmenu, win32con.MF_STRING, 1248, 'Test')&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;На сколько я понимаю есть некое событие при нажатии на нужное мне меню, которое вернет 1248. Но как получать это событие ни как не нагуглю. Нужен перехват для любого окна, которое находится в фокусе.&#xA;Заранее огромное спасибо!	python|windows	9
Проблемы с кодировкой Python 2.7	&lt;img src=&quot;https://i.imgur.com/3HwcFxYl.png&quot; alt=&quot;http://i.imgur.com/3HwcFxYl.png&quot;&gt;&#xA;&#xA;Как можно это исправить? Пробовал разные костыли, ничего не помогло&#xA;	python|кодировка|python-2.x|encoding	9
Книги и учебные ресурсы по Python	Рекомендуемая литература, курсы и документация по Python.&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  Данный перечень входит в поддерживаемый сообществом &lt;a href=&quot;https://ru.stackoverflow.com/questions/454683&quot;&gt;Сборник учебных ресурсов по программированию&lt;/a&gt;.&#xA;&lt;/blockquote&gt;&#xA;	python|книги|faq|python-faq	32
Как вставить OLE объект в Draw в LibreOffice?	Есть таблица в Calc. Есть страница с данными в Draw. Все сделано с помощью pyuno. Как вставить таблицу из Calc в Draw программно через pyuno?&#xA;&#xA;Если просто сделать copy/paste, то это не то, что нужно. Нужно выполнить такие действия: &#xA;&#xA;&lt;blockquote&gt;&#xA;  &quot;Вставка&quot; -&gt; &quot;Объект&quot; -&gt; &quot;Объект OLE...&quot; -&gt; &quot;Создать из файла&quot; -&gt; &quot;Вводится имя файла документа Calc&quot; -&gt; &quot;OK&quot;&#xA;&lt;/blockquote&gt;&#xA;&#xA;Как такое сделать через pyuno?&#xA;&#xA;Пробовал через &lt;code&gt;com.sun.star.frame.DispatchHelper&lt;/code&gt;, но не получилось. Выводит только окно с выбором типа объекта и дальше не идет.&#xA;&#xA;У кого есть какие идеи?&#xA;	python|uno	17
Медленное выполнение кода — подбрасывание монетки миллиард раз	Такой, к примеру, код всего лишь на миллиард итераций выполняется у меня час (60 минут) - что я делаю не так?&#xA;&#xA;&lt;pre&gt;&lt;code&gt;import random&#xA;&#xA;&#xA;reshka = 0&#xA;orel = 0&#xA;i = 0&#xA;while i &amp;lt; 1000000000: &#xA;    coin = random.randint(0, 1)&#xA;    if coin &amp;gt; 0: &#xA;        reshka += 1&#xA;    else:&#xA;        orel += 1&#xA;    i += 1&#xA;print('reshek', reshka, 'orlov', orel)&#xA;&#xA;input()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;	python|производительность	9
прием строки символов из последовательного порта	Это не курсач и не диплом! Я давно уже не студент. Это попытка написать еще одну бесплатную прогу для &quot;домашней&quot; диагностики автомобилей. И я не очень силен в Питоне. Поэтому прошу помощи.&#xA;&#xA;&lt;strong&gt;Исходные данные:&lt;/strong&gt;&#xA;&#xA;Имеется некоторое устройство, которое подключено к компу через USB-порт. Комп и устройство обмениваются данными в символьном виде. По сути, это классическое соединение: устройство -- играет роль сервера, а комп -- роль терминала. Если кому-то что-то это скажет, то это устройство -- это адаптер OBD-II (On-Board Diagnostics -- устройство для диагности автомобилей) ELM327.&#xA;&#xA;Система работает по очень простому принципу -- на запрос (команду) клиента (терминала), сервер возвращает ответ. Вот пример запроса-ответа:&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;gt; ati&#xA;ELM327 v1.5&#xA;&#xA;&amp;gt; atdp&#xA;AUTO, ISO 15765-4 (CAN 11/250)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;Вот так выглядит строка ответа &quot;ELM327 v1.5&quot; в hex виде:&#xA;&#xA;&lt;pre&gt;&lt;code&gt;45 4C 4D 33 32 37 20 76 31 2E 35 0D 0D 3E&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;А так строка ответа &quot;AUTO, ISO 15765-4 (CAN 11/250)&quot;: &#xA;&#xA;&lt;pre&gt;&lt;code&gt;41 55 54 4F 2C 20 49 53 4F 20 31 35 37 36 35 2D 34 20 28 43 41 4E 20 31 31 2F 32 35 30 29 0D 0D 3E&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;Во первых, в строке ответа вместо символа '\n' используется символ '\r'. (Тут нет проблемы. Это легко исправляется.) Во вторых, ответ заканчивается симвлом '&gt;' (hex-код = 0x3E), что приводит к усложнению программного кода обработки ответа. Тут тоже нет неразрешимой проблемы.&#xA;&#xA;Проблема, которую я не могу одолеть, заключается в том, что в Питоне-3 я не могу толком получить из порта строку символов. В Питоне-2.7 запрос-ответ работает без проблем.&#xA;&#xA;Вот код для второго Питона:&#xA;&#xA;&lt;pre&gt;&lt;code&gt;def show_response(port):&#xA;  while True:&#xA;    resp = ''&#xA;    while True:&#xA;      ch = port.read(1)&#xA;      if len(ch) == 1:&#xA;        # print ch&#xA;        if ch == '\r':&#xA;          resp += '\n'&#xA;        else:&#xA;          resp += ch&#xA;&#xA;      if resp[-2:] == '\n&amp;gt;':&#xA;        print resp[:-2],&#xA;        break&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;Для третьего Питона это код (поняное дело!) не подходит. Я не имею в виду замену оператора print для Питон-2 на функцию print() для Питон-3. Это всё легко правится.&#xA;&#xA;Проблема -- в приёме данных от последовательного порта. Если во втором Питоне достаточно сделать (упрощенно говоря) так:&#xA;&#xA;&lt;pre&gt;&lt;code&gt;ch = port.read(1)&#xA;print ch&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;, то в третьем Питоне функция read() возвращает не строку символов, а строку байт.&#xA;&#xA;Я -- Си-шник. И для меня байт-- от и в Африке байт. С моей точки зрения -- что байт, что ASCII-символ (не многобайтовые символы типа utf-8!!!, а именно одно-байтовый ASCII-символ из первой половины таблицы кодов)  -- это один и тот же набор битов. Поэтому функция read() в модуле serial для второго Питона, возвращающая строку символов, и функция read() в модуле serial для третьего Питона, возвращающая строку байт, -- должны давать одинаковый результат.&#xA;&#xA;Но на практике вместо строки байт &quot;45 4C 4D 33 32 ...&quot; (ответ на команду ati во втором Питоне), в третьем Питоне я получаю всего три байта &quot;7F BF ED&quot;. И более уже ничего не могу получить. Обмен между ELM327 и компом происходит байтами (символами ?), находящимися в диапазоне 0..0x7F. Ни какой кириллицей и не пахнет! Откуда такие странные коды -- 0xBF и 0xED ?&#xA;&#xA;Что я делаю не так?&#xA;&#xA;Вот код для третьего Питона:&#xA;&#xA;&lt;pre&gt;&lt;code&gt;def show_response(port):&#xA;  #print('show_response')&#xA;  while True:&#xA;    resp = ''&#xA;    while True:&#xA;      b = port.read(1)&#xA;  if len(b) != 0:&#xA;    print('0x{0:02X}'.format(b[0]))&#xA;    #if ch == '\r':&#xA;    #  resp += '\n'&#xA;    #else:&#xA;    #  resp += ch&#xA;&#xA;  if resp[-2:] == '\n&amp;gt;':&#xA;    print(resp[:-2], end='')&#xA;    break&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;Инициализация порта для второго и третьего Питона практически одинаковая:&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python3&#xA;#coding:utf8&#xA;&#xA;import serial&#xA;import time&#xA;from multiprocessing import Process&#xA;&#xA;...&#xA;&#xA;if __name__ == '__main__':&#xA;  try:&#xA;    port = serial.Serial(&quot;/dev/ttyUSB0&quot;, 38400, timeout=0.2)&#xA;  except serial.SerialException:&#xA;    print('Соединение не удалось')&#xA;    exit(1)&#xA;&#xA;  port.flushOutput()&#xA;  port.flushInput()&#xA;&#xA;  p1 = Process(target=show_response, args=(port,))&#xA;  p1.daemon = True&#xA;  p1.start()&#xA;  command(port)&#xA;  print('Пока-пока!')&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;Пакет serial устанавливал из стандартных репозиториев -- на одном компе (Ubuntu-10.04) это была уставнока пакета для второго Питона ($ sudo apt-get install python-serial), на другом компе (Debian-8) -- для третьего Питона (# apt-get install python3-serial).&#xA;&#xA;Не понимаю, куда копать? Кто-нибудь выпишите мне волшебный пендель в нужном направлении, а то ведь так и помру, не поняв сути Питоновских махинаций с байтами.&#xA;&#xA;&lt;strong&gt;UPDATE 08.08.2015 - 00:53&lt;/strong&gt;&#xA;&#xA;Я изменил прогу, благо она вообще микроскопическая. Сейчас тупо открывается порт, тупо дается команда девасу -- 'ati\r' и тупо выводится на консоль всё, что сыплется из порта в ответ на эту команду -- никаких процессов, никаких ухищрений, ничего лишнего! И тем не менее результат вывода на консоль точно такой же.&#xA;&#xA;Вот текст этой проги:&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python3&#xA;#coding:utf8&#xA;&#xA;import serial&#xA;import time&#xA;&#xA;&#xA;if __name__ == '__main__':&#xA;  try:&#xA;    port = serial.Serial(&quot;/dev/ttyUSB0&quot;, 38400, timeout=1)&#xA;  except serial.SerialException:&#xA;    print('Соединение не удалось')&#xA;    exit(1)&#xA;&#xA;  port.flushOutput()&#xA;  port.flushInput()&#xA;&#xA;  # Послать запрос&#xA;  cmd = bytes('ati\r', 'utf-8')&#xA;  port.write(cmd)&#xA;&#xA;  time.sleep(0.1)&#xA;&#xA;  # Принять ответ и вывести его на консоль&#xA;  while True:&#xA;    print('.')&#xA;&#xA;    resp = port.readline()&#xA;&#xA;    # Вариант вывода 1&#xA;    if len(resp) &amp;gt; 0:&#xA;      print('[{0:d}] = '.format(len(resp)), end = '')&#xA;      for b in resp:&#xA;        print('0x{0:02X} '.format(b), end='')&#xA;&#xA;    '''&#xA;    # Вариант вывода 2&#xA;    string = str(port.readline())&#xA;    if len(string) &amp;gt; 0:&#xA;      print('[{0:d}] = '.format(len(string)), end = '')&#xA;      for ch in string:&#xA;        print('0x{0:02X} '.format(ord(ch)), end='')&#xA;    '''&#xA;&#xA;    '''&#xA;    # Вариант вывода 3&#xA;    string = str(port.readline())&#xA;    if len(string) &amp;gt; 0:&#xA;      print('[{0:d}] = '.format(len(string)), end = '')&#xA;      print(string)&#xA;   '''&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;Вывод по первому варианту такой (скриншот):&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ ./myOBDm2.py&#xA;.&#xA;[2] = 0x7F 0xBF .&#xA;.&#xA;.&#xA;.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;Вывод по второму варианту -- такой:&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ ./myOBDm2.py&#xA;.&#xA;[3] = 0x62 0x27 0x27 .&#xA;[3] = 0x62 0x27 0x27 .&#xA;[3] = 0x62 0x27 0x27 .&#xA;[3] = 0x62 0x27 0x27 .&#xA;[3] = 0x62 0x27 0x27 .&#xA;[3] = 0x62 0x27 0x27 .&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;Вывод по третьему варианту -- такой:&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ ./myOBDm2.py&#xA;.&#xA;[3] = b''&#xA;.&#xA;[3] = b''&#xA;.&#xA;[3] = b''&#xA;.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;Более детальное изучение вывода по третьему варианту намекает, что функция readline() возвращает пустую строку байтов -- ведь три символа &lt;strong&gt;b''&lt;/strong&gt; -- это ничто иное как строка байтов в Питоне. Интересно, чтобы это значило? Почему serial в Питон-3 так странно работает?&#xA;&#xA;Также я пробовал перебирать варианты кодировок при посылке запроса:&#xA;&#xA;&lt;pre&gt;&lt;code&gt;  # Послать запрос&#xA;  cmd = bytes('ati\r', 'utf-8') # 'cp866', 'cp1251', 'ascii'&#xA;  port.write(cmd)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;Ничего не менялось, кодировка никак не влияет.&#xA;&#xA;На девайсе есть светодиода, которые моргают при приёме и передаче данных по USB-интерфейсу. Судя по морганию -- обмен идёт.&#xA;&#xA;&lt;strong&gt;UPDATE 08.08.2015 - 16:47&lt;/strong&gt;&#xA;&#xA;Я сделал два изменения в проге:&#xA;&#xA;&lt;pre&gt;&lt;code&gt;...&#xA;  # Послать запрос&#xA;  cmd = bytes('ati\r\n', 'ascii')  # -1- Добавил '\n'&#xA;  port.write(cmd)&#xA;&#xA;  time.sleep(1)&#xA;&#xA;  # Принять ответ и вывести его на консоль&#xA;  while True:&#xA;    print('.')&#xA;&#xA;    resp = port.read()    # -2- Изменил функцию (была readline)&#xA;&#xA;    # Вариант вывода 1&#xA;    if len(resp) &amp;gt; 0:&#xA;      print('[{0:d}] = '.format(len(resp)), end = '')&#xA;      for b in resp:&#xA;        print('0x{0:02X} '.format(b), end='')&#xA;&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;В результате на консоль получил правильный результат:&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ ./myOBDm2.py&#xA;.&#xA;[1] = 0x61 .&#xA;[1] = 0x74 .&#xA;[1] = 0x69 .&#xA;[1] = 0x0D .&#xA;[1] = 0x45 .&#xA;[1] = 0x4C .&#xA;[1] = 0x4D .&#xA;[1] = 0x33 .&#xA;[1] = 0x32 .&#xA;[1] = 0x37 .&#xA;[1] = 0x20 .&#xA;[1] = 0x76 .&#xA;[1] = 0x31 .&#xA;[1] = 0x2E .&#xA;[1] = 0x35 .&#xA;[1] = 0x0D .&#xA;[1] = 0x0D .&#xA;[1] = 0x3E .&#xA;.&#xA;.&#xA;.&#xA;.&#xA;.&#xA;.&#xA;.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;Но рапортовать о решении проблемы рано, так как проблема исчезляа только для первого (после включения компа) запуска проги. Повтороное и все последующие запуски проги выдавали одинаковые неправильные результаты:&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ ./myOBDm2.py&#xA;.&#xA;[1] = 0x7F .&#xA;[1] = 0xBF .&#xA;[1] = 0xFE .&#xA;.&#xA;.&#xA;.&#xA;.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;Следует заметить, что при возврате ответа от девайса, строки заканчиваются&#xA;символом '\r', а не '\n' и не их комбинацией '\r\n'.&#xA;&#xA;По моим представлениям девайс игнорирует символ '\n'. В описании вообще-то сказано, что девайс игнорирует также и другие &quot;белые&quot; символы (пробел, табуляция, ..). Например, девайс одинково правильно понимает команды 'ati\r' и 'at i\r'.&#xA;&#xA;Таким образом наличие или отсутствие в конце команда символа '\n' никак не влияет на работоспособность девайса, что и подтверждается на практике.&#xA;&#xA;&lt;strong&gt;UPDATE 08.08.2015 - 19:31&lt;/strong&gt;&#xA;&#xA;Хорошо. Перезагружаю комп и смотрю на настройки порта. Настройки порта перед запуском программы следующие:&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ stty -F /dev/ttyUSB0&#xA;speed 57600 baud; line = 0;&#xA;eof = ^A; min = 1; time = 0;&#xA;-brkint -icrnl -imaxbel&#xA;-opost -onlcr&#xA;-icanon -echo -echoe&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;Затем запускаю прогу. Она отрабатывает нормально. Выхожу из проги, и снова смотрю настройки порта:&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ stty -F /dev/ttyUSB0&#xA;speed 38400 baud; line = 0;&#xA;eof = ^A; min = 0; time = 0;&#xA;-brkint -icrnl -imaxbel&#xA;-opost -onlcr&#xA;-isig -icanon -iexten -echo -echoe -echok -echoctl -echoke&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;Оп-па! Что называется -- &quot;Найди семь отличий!&quot;&#xA;&#xA;Методом перебора включения/выключения настроек порта (точнее сказать -- порта_терминала), удалось обнаружить, что &quot;мешается&quot; параметр &lt;strong&gt;-iexten&lt;/strong&gt;.&#xA;&#xA;Если перед запуском проги выключить этот параметр&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ stty -F /dev/ttyUSB0 iexten&#xA;$ stty -F /dev/ttyUSB0&#xA;  speed 38400 baud; line = 0;&#xA;    eof = ^A; min = 0; time = 0;&#xA;    -brkint -icrnl -imaxbel&#xA;    -opost -onlcr&#xA;    -isig -icanon -echo -echoe -echok -echoctl -echoke&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;, то прога снова нормально отрабатывает.&#xA;&#xA;Иначе говоря, модуль serial в Python-3 при открытие порта меняет его настройки. Модуль serial в Python-2 точно так же меняет настройки порта, но здесь (во втором Питоне) эти настройки не приводят к фатальным последствиям.&#xA;&#xA;Теперь осталось найти способ, как при открытии порта в модуле serial для Python-3 указать, что параметр &lt;strong&gt;IEXTEN&lt;/strong&gt; не нужно устанавливать.&#xA;&#xA;Проблема все еще не решена. Продолжаю копать. По мере &quot;лечения&quot; буду публиковать свои шаги.&#xA;&#xA;&lt;strong&gt;UPDATE от 28.08.2015-02:01&lt;/strong&gt;&#xA;&#xA;В результате неспешных попыток заставить девайс ELM327 работать под Питоном-3, я пришел к пониманию, что возможно это не Питон не способен принять ответ от девайса, а наоборот -- Питон не способен передать девайсц команду. Точнее так: Питон передает искаженную команду, девай получает хрен-знает-что и выдает Питону ответ типа &quot;я не понимаю&quot;. Поскольку, Питон работает не правильно, то и ответ он тоже понимает в искаженном виде. Косвенным подтверждением этому является то, что через 30 скунд девас отправляет в комп какую-то короткую &quot;отрыжку&quot;. Я предположил, что это может быть что-то типа &quot;незаконченная команда снимается по тайм-ауту&quot;. По крайней мере такого явления (&quot;отрыжки&quot;) при работе под Питоном-2 не наблюдается. Другими словами, Питон-2 посылает в девайс правильную команду, а Питон-3 искаженную. Соответственно девас так и реагирует.&#xA;&#xA;Что бы проверить то, что Питон-3 посылает бессмыслицу, я поставил несложный (для электронщиков, а я -- электронщик) эксперимент. Я взял два китайских конвертера USB-UART типа CH340G и соединил их по схеме нуль-модема. Затем, подключил один к рабочему компу, на котором прога крутится под Питон-3, а другой к нотиику, на котором точно такая же (ну, за исключением print и некоторых других отличий) прога крутится под Питон-2.&#xA;&#xA;Тогда, если Питон-3 искажает команды, я увижу эти искажения на втором компе.&#xA;&#xA;Да! Существенное дополнение -- в девайсе ELM-327 используется микросхема конвертера CH340T, это клон CH340G.&#xA;&#xA;В результате я увидел, что при передаче данных в обоих направдлениях никаких искажений нет и в помине! Пробовал на разных скоростях обмена. Все работает чётко. Отсюда вывод -- проблемы в связке девайса и Питона-3.&#xA;&#xA;Устройство ELM327 -- неразборное, чем-то напоминает блоки питания для нотиков. Пришлось крушить корпус молотком. Вскрыл более-менее нормально.&#xA;&#xA;А вот далее начинается вторая серия детектива.&#xA;&#xA;Я подключил осциллограф к выходу UART-а микросхемы CH340T, чтобы посмотреть, что она передает непосредственно в микроконтроллер.&#xA;&#xA;Держитесь за стул! Оказывается, что микросхема передает правильные данные, но не на той скорости, какую мы ожидаем. Точнее так, в питоновской программе при инициализации последовательного порта указывается скорость работы. Программа, работающая под Питон-2, настраивает микросхему CH340T на заданную скорость. А вот программа, работающая под Питон-3, по какой-то неведомой причине не может настроить эту микросхему. В результате получается, что прога из-под Питона-2 обращается к микроконтроллеру на скорости 38400, а прога из-под Питона-3 -- на скорости 9600 Бод.&#xA;&#xA;Микроконтроллер ожидает, что к нему будут &quot;стучаться&quot; на 38400, и по этому он, естественно, не правильно понимает команду от компа. Далее микроконтроллер выдает ответ типа &quot;Вы что там, совсем охренели?&quot; на скорости 38400, но CH340T принимает это на скорости 9600 и передает в комп мусор. А через 30 секунд микрконтроллер посылает в комп еще один пакет типа &quot;Да ну вас нахрен! Эту команду я снимаю. Вводите следующую!&quot;.&#xA;&#xA;Теперь мне нужно понять -- почему Питон-3 не способен правильно проинициализировать микросхему конвертера CH340T.&#xA;&#xA;&lt;strong&gt;UPDATE от 28.08.2015-04:05&lt;/strong&gt;&#xA;&#xA;Скажу сразу -- проблему победить не удалось, но удалось нащупать &quot;обходной путь&quot;. Рецепт прост -- в Питоне-3 не следует производить одновременно инициализацию порта и установку скорости.&#xA;&#xA;Так делать не надо:&#xA;&#xA;&lt;pre&gt;&lt;code&gt;  try:&#xA;    port = serial.Serial(&quot;/dev/ttyUSB0&quot;, 38400, timeout=0.2)&#xA;  except serial.SerialException:&#xA;    print('Соединение не удалось')&#xA;    exit(1)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;Следует делать так:&#xA;&#xA;&lt;pre&gt;&lt;code&gt;  try:&#xA;    port = serial.Serial(&quot;/dev/ttyUSB0&quot;)&#xA;    port.baudrate = 38400&#xA;    port.timeout = 0.2&#xA;  except serial.SerialException:&#xA;    print('Соединение не удалось')&#xA;    exit(1)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;Я так понимаю, что это накосячено где-то в конструкторе класса Serial. Но заниматься ремонтом этого дурдома меня что-то больше не прёт.&#xA;	python|linux|python-3.x|serial	9
Оператор присваивания += для списков (добавление по месту)	Как работает оператор &lt;code&gt;+=&lt;/code&gt; и аналогичные ему? То есть, понятно, что &lt;code&gt;x+=y&lt;/code&gt; - это аналог &lt;code&gt;x = x + y&lt;/code&gt;. &#xA;&#xA;Но я столкнулся с такой проблемой: &#xA;&#xA;&lt;pre&gt;&lt;code&gt;x = []&#xA;y = (1,2,3)&#xA;x = x + y&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;В этом случае будет ошибка:&#xA;&#xA;&lt;blockquote&gt;&#xA;  TypeError: can only concatenate list (not &quot;tuple&quot;) to list&#xA;&lt;/blockquote&gt;&#xA;&#xA;Но если написать&#xA;&#xA;&lt;pre&gt;&lt;code&gt;x += y&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;То значение &lt;code&gt;x&lt;/code&gt; будет выводиться как&#xA;&#xA;&lt;pre&gt;&lt;code&gt;[1, 2, 3]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;	python	11
Как бессмысленное изменение оператора проверки влияет на скорость кода Cython?	У меня есть следующие два варианта кода для Cython:&#xA;&#xA;Вариант 1:&#xA;&#xA;&lt;pre&gt;&lt;code&gt;cpdef prime(int n):&#xA;    cdef int i&#xA;    if n &amp;lt; 2: return False&#xA;    for i in xrange(3, int(n**0.5) + 2, 2):&#xA;        if not n % i: return False&#xA;    return True&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;Вариант 2:&#xA;&#xA;&lt;pre&gt;&lt;code&gt;cpdef prime(int n):&#xA;    cdef int i&#xA;    if n &amp;lt; -1: return False&#xA;    for i in xrange(3, int(n**0.5) + 2, 2):&#xA;        if not n % i: return False&#xA;    return True&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;Как видно, единственная разница в строке:&#xA;&#xA;&lt;pre&gt;&lt;code&gt;if n &amp;lt; -1: return False&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;Вызывается один из вариантов этого кода из Python самым обычным образом:&#xA;&#xA;&lt;pre&gt;&lt;code&gt;for i in xrange(10000):&#xA;    result = prime(1007963447)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;Проверяю только на этом числе, никаких n &amp;lt; 2, а тем более n &amp;lt; -1.&#xA;&#xA;Время выполнения для каждого варианта:&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Вариант 1: 1.20464787483&#xA;Вариант 2: 0.90665817260&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Если заменить строку &lt;code&gt;if n &amp;lt; 2: return False&lt;/code&gt; на &lt;code&gt;if False: return&lt;/code&gt;&#xA;или &lt;code&gt;if n &amp;lt; 0: pass&lt;/code&gt;, время выполнения опять возрастает до ~1.10sec.&lt;/li&gt;&#xA;&lt;li&gt;Если заменить на &lt;code&gt;if n &amp;lt; 0: return False&lt;/code&gt; или &lt;code&gt;if n &amp;lt; 0: return&lt;/code&gt;, то&#xA;время выполнения не меняется (~0.9sec).&lt;/li&gt;&#xA;&lt;li&gt;Если вообще убрать эту строку, то время выполнения возрастает до&#xA;~1.10sec.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;Пробовал разные варианты. Среда разработки, кодировки и фазы луны не влияют на результат, влияет только эта строка.&#xA;&#xA;Вопрос: почему такие бессмысленные изменения ускоряют\змедляют работу кода? Или я чего-то не понимаю?&#xA;&#xA;UPD. Вот наглядная разница в сгенерированных файлах &quot;*.c&quot;: &lt;a href=&quot;https://www.diffnow.com/?report=7h5km&quot;&gt;Diff Online&lt;/a&gt;&#xA;&#xA;Единственная разница в соответствующих строках:&#xA;&#xA;&lt;pre&gt;&lt;code&gt;pyx_t_1 = ((__pyx_v_n &amp;lt; -1) != 0);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;и&#xA;&#xA;&lt;pre&gt;&lt;code&gt;pyx_t_1 = ((__pyx_v_n &amp;lt; 2) != 0);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;UPD2. Также добавил сравнение ассемблерных листингов (слева n&amp;lt;2): &lt;a href=&quot;https://www.diffnow.com/?report=nqu8d&quot;&gt;Assembler listing&lt;/a&gt;&#xA;	python|производительность|cython	21
Добавление префикса к url которые формирует django	Есть middleware который проверяет url на наличие префикса в адресе и редиректит, при его отсутствии, на адрес с префиксом. При этом заменяя значения в request так чтобы казалось что этого префикса нету. Всё работает хорошо, за исключением того что новые url генерируются без этого префикса, что приводит к избыточному редиректу. &#xA;&#xA;Есть ли какой-нибудь способ глобально переопределить методы для формирования url'ов, чтобы они формировались с нужным мне префиксом? Т.е. есть модель, которая зарегистрирована для редактирование в django админке, необходимо чтобы url'ы, которые генерирует сам django были сразу с префиксами.&#xA;&#xA;P.S. Префикс стоит перед сигнатурой языка, для этого и необходимо прикидываться.&#xA;&#xA;P.S.S. Модели могут быть не моего приложения и доступа к их коду у меня нету.&#xA;	python|django|django-admin|django-cms	9
Есть ли в Python оператор switch case?	Столкнулся с тем, что требуется реализовать множественное условие, которое в других языках я бы реализовал с помощью конструкции &lt;code&gt;switch-case&lt;/code&gt;. &#xA;&#xA;В Python мне приходится расписывать всё через условия &lt;code&gt;if-elif-else&lt;/code&gt;. Это мне кажется довольно неудобным. &#xA;&#xA;Есть ли более удобный способ записи подобных условий?&#xA;&#xA;Например, у меня есть единицы измерения и в зависимости от выбранной мне нужно вернуть соответствующий множитель:&#xA;&#xA;&lt;pre&gt;&lt;code&gt;def get_multiplier(unit):&#xA;    if unit == 'mm':&#xA;        return 10**-3&#xA;    if unit == 'cm':&#xA;        return 10**-2&#xA;    if unit == 'dm':&#xA;        return 10**-1&#xA;    if unit == 'm':&#xA;        return 1&#xA;    if unit == 'km':&#xA;        return 10**3&#xA;    raise ValueError('Undefined unit: {}'.format(unit))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;	python	26
Определить общие темы среди множеств слов	Путем долгих переборов, удалений, парсинга, стемминга и др. анализов я пришел к ТОП 10 слов для каждой лекции с ted.com. Они достаточно уникальные, т.е. среди 2346 множеств слов максимально из них повторяется не более 50 слов.&#xA;&#xA;Задача состоит в том, чтобы выявить на основе полученных 2346 множеств слов по 10 схожие. Простое пересечение множеств каждого с каждым ни к чему не приводит (длина пересечения 1-3). Нужно использовать синонимы. Пытался разобраться с gensim и nltk, но ни к чему не пришел. LSA не настроил.&#xA;&#xA;Направьте на истинный путь в этом нелегком деле.&#xA;	python|текст	14
Нейросеть для обработки одномерного массива	Добрый вечер,&#xA;Необходимо создать нейросеть для определения зависимости на последовательности.&#xA;Например у нас есть эталонная зависимость &#xA;&#xA;&lt;pre&gt;&lt;code&gt;[0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;И также у нас есть входные данные, которые могут быть смещены: &#xA;&#xA;&lt;pre&gt;&lt;code&gt;[0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;На выходе хотелось бы иметь какое-то число от 0 до 1 с вероятностью совпадения.&#xA;Буду рад услышать и увидеть любой материал, ссылки, а еще лучше псевдо- или обычный код.&#xA;	python|нейронные-сети	11
Что такое Anaconda для Python?	Что такое &lt;a href=&quot;https://www.continuum.io/&quot; rel=&quot;nofollow noreferrer&quot;&gt;Anaconda&lt;/a&gt; ?&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Какие задачи она позволяет решать, и почему нельзя без нее обойтись?&lt;/li&gt;&#xA;&lt;li&gt;Стоит ли её ставить новичку параллельно с установленными Python`ами 32 + 64.&#xA;Чем она может помочь? Если можно на доступном языке для совсем начинающего. &lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;	python|python-3.x|conda	11
Поиск прямоугольника на изображении	&lt;strong&gt;Задача&lt;/strong&gt;: &#xA;Найти жёсткий диск на фото, определить его угол и контуры&#xA;&#xA;&lt;strong&gt;Проблема:&lt;/strong&gt;&#xA;Не всегда удаётся найти правильный контур диска.&#xA;&#xA;В коде я делаю изображения серыми, блюрю, нахожу разницу между ними и определяю контуры, но решение не точное. Хотелось бы вашей помощи.&#xA;&#xA;&lt;pre&gt;&lt;code&gt;firstFrame = cv2.imread(bg_im)  # Фоновое изображение без диска&#xA;frame_img = cv2.imread(frame)   # Изображение с диском&#xA;&#xA;gray = cv2.cvtColor(frame_img, cv2.COLOR_BGR2GRAY)&#xA;gray = cv2.GaussianBlur(gray, (21, 21), 0)&#xA;firstFrame = cv2.cvtColor(firstFrame, cv2.COLOR_BGR2GRAY)&#xA;firstFrame = cv2.GaussianBlur(firstFrame, (21, 21), 0)&#xA;&#xA;frameDelta = cv2.absdiff(firstFrame, gray)&#xA;thresh = cv2.threshold(frameDelta, 25, 255, cv2.THRESH_BINARY)[1]&#xA;thresh = cv2.dilate(thresh, None, iterations=2)&#xA;(cnts, _) = cv2.findContours(thresh.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)&#xA;&#xA;c = sorted(cnts, key = cv2.contourArea, reverse = True)[0]&#xA;&#xA;rect = cv2.minAreaRect(c)&#xA;box = cv2.cv.BoxPoints(rect)&#xA;&#xA;x1 = box[0][0]&#xA;x2 = box[1][0]&#xA;x4 = box[3][0]&#xA;&#xA;y1 = box[0][1]&#xA;y2 = box[1][1]&#xA;y4 = box[3][1]&#xA;&#xA;perimeter_1_4 = sqrt((x4 - x1)**2 + (y1 - y4)**2)&#xA;perimeter_1_2 = sqrt((x2 - x1)**2 + (y1 - y2)**2)&#xA;&#xA;box = np.int0(box)&#xA;corner = list(rect)[2]&#xA;&#xA;if perimeter_1_4 &amp;gt; perimeter_1_2:&#xA;    corner = -(90 - corner)    &#xA;&#xA;cv2.drawContours(frame_img,[box],0,(0,0,255),2)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;a href=&quot;https://i.stack.imgur.com/TtUIZ.jpg&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/TtUIZ.jpg&quot; alt=&quot;Фон. Без диска&quot;&gt;&lt;/a&gt;&#xA;&lt;a href=&quot;https://i.stack.imgur.com/RpE06.jpg&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/RpE06.jpg&quot; alt=&quot;Фон. Без диска&quot;&gt;&lt;/a&gt;&#xA;	python|opencv	13
Как найти все дублирующиеся элементы в списке и количество их повторов?	Нужна функция, которая, например, для списка &lt;code&gt;[10, 10, 23, 10, 123, 66, 78, 123]&lt;/code&gt; вернёт &lt;code&gt;{10: 3, 123: 2}&lt;/code&gt;.&#xA;	python|массивы|алгоритм|списки|повторы	10
Распознавание знака бесконечности	Как можно распознать знак бесконечности (именно его) на фото или видео?&#xA;&#xA;Буду признателен, если приведете код к ответу.&#xA;&#xA;UPD:&#xA;Объясните, как, например, с помощью контурного анализа понять, есть ли на фотографии знак бесконечности. Пример ниже (в центре может быть полное соединение, человека может быть видно - он может держать лист, цвет не важен).&#xA;&#xA;&lt;a href=&quot;https://i.stack.imgur.com/PaJvb.jpg&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/PaJvb.jpg&quot; alt=&quot;Контуры могут смежаться, человека может быть видно - он может держать лист, цвет не важен&quot;&gt;&lt;/a&gt;&#xA;	python|opencv	12
Почему буквы алфавита с &quot;р&quot; по &quot;ю&quot; не входят в диапазон &quot;а-я&quot;?	&lt;strong&gt;Поясню сразу&lt;/strong&gt;: я знаю, что python 2 требует явного объявления строк как юникодовых. Понимаю, что это и не должно работать корректно. Мне интересна &quot;анатомия&quot; поломки. Что именно внутри &lt;code&gt;re.compile()&lt;/code&gt; и &lt;code&gt;regex.search()&lt;/code&gt; производит такой результат?&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;Судя по нижеприведённому коду, диапазон &lt;code&gt;'а-яё'&lt;/code&gt; не включает в себя диапазон &lt;code&gt;'р-ю'&lt;/code&gt;, зато диапазон &lt;code&gt;'р-ю'&lt;/code&gt; включает &lt;code&gt;'ё'&lt;/code&gt;. &#xA;&#xA;&lt;em&gt;mcve.py:&lt;/em&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;# coding=utf-8&#xA;&#xA;import re&#xA;&#xA;# Это панграмма, она содержит все буквы алфавита&#xA;test = 'широкая электрификация южных губерний даст мощный толчок подъёму сельского хозяйства'&#xA;&#xA;regex1 = re.compile('[а-яА-ЯёЁ\s]+')&#xA;regex2 = re.compile('[а-яА-ЯёЁшьрэтфцюыхущчъ\s]+')&#xA;regex3 = re.compile('[а-яёшьрэтфцюыхущчъс\s]+')&#xA;regex4 = re.compile('[а-яр-ю\s]+')&#xA;&#xA;print regex1.search(test).group()&#xA;print regex2.search(test).group()&#xA;print regex3.search(test).group()&#xA;print regex4.search(test).group()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;Результат:&#xA;&#xA;&lt;blockquote&gt;&#xA;  �&lt;br&gt;&#xA;  широкая электрификация южных губерний даст мощный толчок подъёму сельского хозяйства&lt;br&gt;&#xA;  широкая электрификация южных губерний даст мощный толчок подъёму сельского хозяйства&lt;br&gt;&#xA;  широкая электрификация южных губерний даст мощный толчок подъёму сельского хозяйства  &#xA;&lt;/blockquote&gt;&#xA;&#xA;Я убедился, что все буквы алфавита от &quot;А&quot; до &quot;Я&quot; и от &quot;а&quot; до &quot;я&quot; &lt;a href=&quot;http://unicode-table.com/en/#cyrillic&quot;&gt;идут в Юникоде подряд&lt;/a&gt;, кроме &quot;Ёё&quot;, которые явным образом добавлены в регулярное выражение. &#xA;&#xA;Постепенно добавляя буквы, на которых прерывается поиск по первому выражению, я пришёл к диапазону &lt;code&gt;а-яА-ЯёЁшьрэтфцюыхущчъ&lt;/code&gt;. Если отсортировать добавленные буквы, получается почти сплошной интервал: &lt;code&gt;&quot;ртуфхцчшщъыьэю&quot;&lt;/code&gt;.&#xA;&#xA;Если убрать заглавные буквы, т.е. &lt;code&gt;&quot;[А-ЯЁ]&quot;&lt;/code&gt;, то неожиданным образом поиск прерывается на &quot;с&quot;. Интервал становится сплошным: с &quot;р&quot; и до &quot;ю&quot;. Это &lt;code&gt;regex3&lt;/code&gt;.&#xA;&#xA;И наконец оказывается, что теперь интервал можно свернуть и даже убрать &quot;ё&quot; (&lt;code&gt;regex4&lt;/code&gt;). &#xA;&#xA;Что вообще происходит?&#xA;&#xA;&lt;pre&gt;&lt;code&gt; python --version&#xA;Python 2.7.6&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;Если явным образом сделать юникодовую строку и регулярное выражение, то всё работает как должно. Но ведь как-то работает и без этого. Объясните, как?&#xA;&#xA;&lt;pre&gt;&lt;code&gt;test2 = u'широкая электрификация южных губерний даст мощный толчок подъёму сельского хозяйства'&#xA;regex5 = re.compile(u'[а-яА-ЯёЁ\s]+')&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;	python|регулярные-выражения|кодировка|python-2.x|unicode	10
Какова структура файла байткода CPython?	Пытаюсь разобраться в структуре скомпилированного байт-кода CPython.&lt;br&gt;&#xA;Допустим, у меня есть файл &lt;code&gt;foo.py&lt;/code&gt; следующего содержания:&#xA;&#xA;&lt;pre&gt;&lt;code&gt;def hello(name):&#xA;    print(&quot;Hello, %s&quot; % name)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;Скомпилированный &lt;code&gt;__pycache__\foo.cpython-35.pyc&lt;/code&gt; выглядит так:&#xA;&#xA;&lt;img src=&quot;https://i.stack.imgur.com/4Nwy1.png&quot; alt=&quot;байткод&quot;&gt;&#xA;&#xA;Дальше что я понял:&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;16 0d 0d 0a&lt;/code&gt; - это &lt;a href=&quot;https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D0%B3%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5_%D1%87%D0%B8%D1%81%D0%BB%D0%BE_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)#.D0.A1.D0.B8.D0.B3.D0.BD.D0.B0.D1.82.D1.83.D1.80.D0.B0_.D0.B4.D0.B0.D0.BD.D0.BD.D1.8B.D1.85&quot; rel=&quot;noreferrer&quot;&gt;магическое число&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;06 e2 7f 57&lt;/code&gt; - дата последнего изменения&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;31 00 00 00&lt;/code&gt; - размер файла (должен быть - хотя в файле 216 байт, так что я не знаю, что это за размер на самом деле)&lt;/li&gt;&#xA;&lt;li&gt;следующие 22 байта (&lt;code&gt;e3 00 00 00 ... 00 00 00 73&lt;/code&gt;) - не знаю для чего&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;10 00 00 00&lt;/code&gt; - видимо размер кода модуля (но тогда получается что предыдущий символ должен быть типом, а это &lt;code&gt;73&lt;/code&gt; - код строкового типа)&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;64 00 00&lt;/code&gt;, &lt;code&gt;64 01 00&lt;/code&gt; - &lt;code&gt;LOAD_CONST(0); LOAD_CONST(1)&lt;/code&gt;,&#xA;где константа 0 - &lt;code&gt;code object&lt;/code&gt; функции, константа 1 - её имя (&lt;code&gt;&quot;hello&quot;&lt;/code&gt;)&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;84 00 00&lt;/code&gt; - &lt;code&gt;MAKE_FUNCTION(0)&lt;/code&gt;, только я так и не понял, зачем нужен аргумент этого опкода&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;5a 00 00&lt;/code&gt; - &lt;code&gt;STORE_NAME(0)&lt;/code&gt;, где имя 0 - имя функции (&lt;code&gt;&quot;hello&quot;&lt;/code&gt;)&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;64 02 00 53&lt;/code&gt; - &lt;code&gt;LOAD_CONST(2); RETURN_VALUE&lt;/code&gt;, где константа 2 - &lt;code&gt;None&lt;/code&gt; (правда не совсем понятно зачем модулю возвращать что-то)&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;29 03&lt;/code&gt; - кортеж констант модуля: &lt;code&gt;(&amp;lt;code object hello&amp;gt;, &quot;hello&quot;, None)&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;следующие 18 байт (&lt;code&gt;74 00 00 64 ... 64 00 00 53&lt;/code&gt;) - код функции &lt;code&gt;hello&lt;/code&gt; (тот который &lt;code&gt;hello.__code__.co_code&lt;/code&gt;)&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;29 02&lt;/code&gt; - кортеж констант функции: &lt;code&gt;(None, &quot;Hello, %s&quot;)&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;4e&lt;/code&gt; - тип константы &lt;code&gt;NONE&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;7a 09&lt;/code&gt; - тип строковой константы (&lt;code&gt;SHORT_ASCII&lt;/code&gt;) и длина строки &lt;code&gt;&quot;Hello, %s&quot;&lt;/code&gt; (9 символов)&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;48 65 6c 6c 6f 2c 20 25 73&lt;/code&gt; - строка &lt;code&gt;&quot;Hello, %s&quot;&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;29 01&lt;/code&gt; - кортеж имён функции: &lt;code&gt;(&quot;print&quot;,)&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;da 05&lt;/code&gt; - здесь вроде должен быть один из строковых типов, но вместо него несуществующий тип &lt;code&gt;da&lt;/code&gt;; &lt;code&gt;05&lt;/code&gt; - длина строка&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;70 72 69 6e 74&lt;/code&gt; - имя функции &lt;code&gt;print&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;29 01&lt;/code&gt; - кортеж имён локальных переменных: &lt;code&gt;(&quot;name&quot;,)&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;da 04&lt;/code&gt; - опять неизвестный тип &lt;code&gt;da&lt;/code&gt; и длина строки &lt;code&gt;04&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;6e 61 6d 65&lt;/code&gt; - имя переменной &lt;code&gt;name&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;a9 00 72 03 00 00 00&lt;/code&gt; - не понял&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;fa 06&lt;/code&gt; - ещё один непонятный тип &lt;code&gt;fa&lt;/code&gt; и длина строки &lt;code&gt;06&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;66 6f 6f 2e 70 79&lt;/code&gt; - имя файла модуля (&lt;code&gt;foo.py&lt;/code&gt;)&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;da 05&lt;/code&gt; - непонятный тип &lt;code&gt;da&lt;/code&gt; и длина строки &lt;code&gt;05&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;68 65 6c 6c 6f&lt;/code&gt; - имя функции &lt;code&gt;hello&lt;/code&gt; (правда нет объявления кортежа имён модуля или вроде того)&lt;/li&gt;&#xA;&lt;li&gt;следующие 17 байт (&lt;code&gt;01 00 00 00 ... 00 00 00 4e&lt;/code&gt;) - не понял&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;29 01&lt;/code&gt; - какой-то кортеж длиной в один элемент&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;72 ...&lt;/code&gt; - константа типа &lt;code&gt;ref&lt;/code&gt; (что это за тип?)&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;da 08&lt;/code&gt; - снова загадочный типа &lt;code&gt;da&lt;/code&gt; и длина строки 08&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;3c 6d 6f 64 75 6c 65 3e&lt;/code&gt; - строка &lt;code&gt;&quot;&amp;lt;module&amp;gt;&quot;&lt;/code&gt; (зачем?)&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;01 ...&lt;/code&gt; - дальше не знаю что&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;Помогите восполнить пробелы. Если бы мне надо было просто узнать значение какой-нибудь константы, то мне бы имеющихся знаний хватило. Но я пытаюсь написать интерпретатор байт-кода Python, так что мне надо полностью разобраться со структурой &lt;code&gt;.pyc&lt;/code&gt;-файлов.&#xA;	python|python-3.5|python-3.6|python-faq|байткод	23
Сравнение двух списков на нахождение элементов которые соответствуют правилам	Вопрос заключается в том, что например у меня есть два списка:&#xA;&#xA;&lt;pre&gt;&lt;code&gt;lst1 = ['1', '2' , '3' , '4']&#xA;lst2 = ['123', '234' , '345' , '334']&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;Как мне найти такие элементы во втором списке, которые включают в себя только те элементы, которые есть в первом, но, если в первом списке есть одна единица, то например элемент &quot;112&quot; с второго списка не подходит.&#xA;&#xA;Tо есть результатом программы должен быть &#xA;&#xA;&lt;pre&gt;&lt;code&gt;ls3 = ['123', '234']&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;'345' - не подошло потому что там есть элемент &quot;5&quot; которого нет в первом списке&#xA;&#xA;'334' - не подошло потому что там есть два элемента &quot;3&quot;, а в первом списке элемент &quot;3&quot; есть только один&#xA;	python|алгоритм|python-3.x|list	9
Что значит * (звёздочка) и ** двойная звёздочка в Питоне?	К примеру, что делает &lt;code&gt;*&lt;/code&gt; (астериск) в следующем коде:&#xA;&#xA;&lt;pre&gt;&lt;code&gt;print(*min(p for p in counter.items() if p[1] == max_count))&#xA;&#xA;print(*team, *coef)&#xA;&#xA;seasons = [datetime(*args) for args in [&#xA;    (Y, 1, 1), # winter&#xA;    (Y, 3, 1), # spring&#xA;    (Y, 6, 1), # summer&#xA;    (Y, 9, 1), # autumn&#xA;    (Y, 12, 1) # winter&#xA;]]&#xA;&#xA;def lcm(*args):&#xA;    &quot;&quot;&quot;Least common multiple.&quot;&quot;&quot;&#xA;    return reduce(lambda a, b: a * b // gcd(a, b), args)&#xA;&#xA;async def watchdog(loop, last_activity_time, timeout, func, *args):&#xA;    &quot;Run *func(*args)* if more than *timeout* seconds since *last_activity_time*.&quot;&#xA;    while (loop.time() - last_activity_time()) &amp;lt; timeout:&#xA;        await asyncio.sleep(1)&#xA;    return func(*args)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;и что делают две &lt;code&gt;**&lt;/code&gt; звёздочки:&#xA;&#xA;&lt;pre&gt;&lt;code&gt;'{a:.{n}f}'.format(**vars())&#xA;&#xA;class A:&#xA;    def __init__(self, a, **kwargs):&#xA;        super().__init__(**kwargs)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;	python|python-3.x	15
Запрещать явно наследоваться от object	&lt;strong&gt;Описание проблемы:&lt;/strong&gt;&#xA;&#xA;В Python-2.x, если нужно было объявить &lt;a href=&quot;https://www.python.org/doc/newstyle/&quot; rel=&quot;noreferrer&quot;&gt;new-style класс&lt;/a&gt;, приходилось явно наследоваться от &lt;code&gt;object&lt;/code&gt;, например:&#xA;&#xA;&lt;pre&gt;&lt;code&gt;class A(object):&#xA;    def __init__(self, prop):&#xA;        self.prop = prop &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;В Python-3.x классы неявно объявляются наследниками &lt;code&gt;object&lt;/code&gt;, можно написать просто:&#xA;&#xA;&lt;pre&gt;&lt;code&gt;class A:&#xA;    def __init__(self, prop):&#xA;        self.prop = prop &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;Но, оба варианта объявления класса будут работать в 3.x.&#xA;&#xA;&lt;strong&gt;Вопрос:&lt;/strong&gt;&#xA;&#xA;Можно ли, с помощью статического анализа кода и инструментов вроде &lt;code&gt;pylint&lt;/code&gt;, &lt;code&gt;flake8&lt;/code&gt; запретить первый, устаревший вариант объявления класса?&#xA;&#xA;&lt;sub&gt;Пожалуйста, не судите строго - это мой первый вопрос на ru.SO.&lt;/sub&gt;&#xA;	python|python-3.x|статический-анализ|pylint	10
Что такое объект в Python. Почему id(a) == id(b) == id(1)?	Детализирую вопрос.&lt;br&gt;&#xA;В книгах по Python пишут, что все в Python есть объект.&#xA;&#xA;Берем традиционный подход к изучению/обучению языкам программирования.&#xA;Языки Pascal, C, C++, у них есть понятие  &quot;имя переменной&quot; (идентификатор). С именем переменной связывается/присваивается значение. Значение хранится в памяти. Имя переменной - это способ (в исходном тексте программы) обратиться к ячейке памяти для получения значения, которое там хранится. &#xA;&#xA;Не знаю верно ли высказывание (для компилируемых языков): Для  переменных, например, целого типа, в момент выполнения программы на компьютере, процессор работает уже с адресами ячеек памяти, где хранятся значения переменных. Т.е. не такого, что где-то по какому-то адресу хранится имя переменной и оно связывается с адресом ячейки, в которой хранится значение.&#xA;&#xA;Теперь переходим к Python. В этом языке все является объектом, даже определение функции.&lt;br&gt;&#xA;Переменная объект, значение объект и т.д. В разное время с одним и тем же объектом может соотноситься разный другой объект. &#xA;&#xA;&lt;pre&gt;&lt;code&gt;a = 1&#xA;print(a)&#xA;a = &quot;Hello&quot;&#xA;print(a)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;Но тогда как понять действие функции &lt;code&gt;id()&lt;/code&gt;? По определению стандарта&#xA;она возвращает &quot;identify&quot; указанного объекта. Причем, &quot;возвращает целое, гарантированно являющееся &lt;strong&gt;уникальным&lt;/strong&gt;&quot; и постоянным для объекта на время его существования.&quot;&#xA;&#xA;Тогда почему &#xA;&#xA;&lt;pre&gt;&lt;code&gt;a = 1&#xA;b = 1&#xA;print(id(a) == id(b) == id(1))  # True&#xA;print(&quot;Why?&quot;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;ведь a, b, 1 разные объекты?&lt;br&gt;&#xA;По-моему вопрос получился...&#xA;&#xA;Используется Python 3.6&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;Про значения от -5 до 256 наслышан. Имеет место быть&#xA;&#xA;&lt;pre&gt;&lt;code&gt;a = 1000000&#xA;b = 1000000&#xA;print(id(a) == id(b))  # True&#xA;print(&quot;Why?&quot;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;На счет того, что достаточно &quot;знать об именах и т.д.&quot;. Для меня не достаточно, потому и спрашиваю у уважаемых профи. В Питоне все объект. Нет имен переменных. Отсюда и мой вопрос.&#xA;	python|python-3.x|python-internals	10
Рекурсивный алгоритм. Переполнение стека	Привет. У меня много раз вызывается рекурсивный dfs, после чего я получаю &lt;code&gt;RuntimeError: maximum recursion depth exceeded in __instancecheck__&lt;/code&gt;. Такое ощущение, что происходит накопление рекурсивных вызовов за всё время работы программы. После превышения порога в сумме&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sys.setrecursionlimit(20000)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;прога падает. Как с этим бороться?&#xA;&#xA;Для большей конкретики я приведу псевдокод моего алгоритма:&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func dfs(current):&#xA;    global labels&#xA;    labels[current] = true&#xA;    for neighbour in get_neighbours(current):&#xA;        if not (labels[neighbour]):&#xA;            dfs(neighbour)&#xA;        do_smth()&#xA;&#xA;for item in range(0, n):&#xA;   dfs(item) // Происходит несколько итераций цикла, после чего прога падает. При увеличении значения n в sys.setrecursionlimit(n) алгоритм выполняет больше итераций в цикле, но всё равно падает.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;Таким образом, в некоторый момент возникает вышеуказанная ошибка. Замечу, что данная ошибка возникает у меня уже не первый раз. Возникает она в любом месте, где есть достаточное количество вызовов рекурсивных алгоритмов с большой глубиной рекурсии.&#xA;&#xA;Замечу, что в коде нет терминального условия, но это не означает, что код будет выполняться бесконечно. Прокомментирую. Мы рассматриваем граф G(V, E). Будем перебирать вершины, начиная с любой. Каждую вершину мы будем помечать, если мы в ней были. Это делается следующей командой: &#xA;&#xA;&lt;pre&gt;&lt;code&gt;labels[current] = true&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;Для каждой вершины мы перебираем всех её соседей:&#xA;&#xA;&lt;pre&gt;&lt;code&gt;for neighbour in get_neighbours(current):&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;Если в вершине-соседе мы были, то в неё заходить не следует. Если же нет, то перейдём в нее. Проверка были мы там или нет осуществляется так:&#xA;&#xA;&lt;pre&gt;&lt;code&gt;if not (labels[neighbour]):&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;Далее переходим в вершину:&#xA;&#xA;&lt;pre&gt;&lt;code&gt;dfs(neighbour)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;О конкретном алгоритме можно прочесть &lt;a href=&quot;http://informatics.mccme.ru/mod/resource/view.php?id=1035&quot; rel=&quot;noreferrer&quot;&gt;здесь&lt;/a&gt;. Но спешу заметить, что вопрос заключается не в алгоритме, а в принципах устройства python. Подробное описание кода я привёл лишь для того, чтобы снять сомнения в его работоспособности. Код взят лишь как пример и не более того! &#xA;	python|алгоритм|рекурсия	10
Как писать в stdout и в файл одновременно?	Есть python скрипт:&#xA;&#xA;&lt;pre&gt;&lt;code&gt;import sys&#xA;sys.stdout = open('my_log.log', 'w')&#xA;print 'test'&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;Он пишет весь стандартный вывод в файл. Вопрос: как мне и писать в файл, и одновременно выводить на консоль?&#xA;	python	10
Как осуществить поиск объекта на изображении с помощью полносверточной нейронной сети	Здравствуйте, стоит задача поиска объекта с помощью полносверточной нейронной сети, используя Keras, theano, на языке python. На данный момент используется вот такая конфигурация сети: &#xA;&#xA;&lt;pre&gt;&lt;code&gt;def create_encoding_layers():&#xA;    kernel = 3&#xA;    filter_size = 64&#xA;    pad = 1&#xA;    pool_size = 2&#xA;    return [&#xA;        ZeroPadding2D(padding=(pad,pad)),&#xA;        Convolution2D(filter_size, kernel, kernel, border_mode='valid'),&#xA;        BatchNormalization(),&#xA;        Activation('relu'),&#xA;        MaxPooling2D(pool_size=(pool_size, pool_size)),&#xA;&#xA;        ZeroPadding2D(padding=(pad,pad)),&#xA;        Convolution2D(32, kernel, kernel, border_mode='valid'),&#xA;        BatchNormalization(),&#xA;        Activation('relu'),&#xA;        MaxPooling2D(pool_size=(pool_size, pool_size)),&#xA;&#xA;        ZeroPadding2D(padding=(pad,pad)),&#xA;        Convolution2D(32, kernel, kernel, border_mode='valid'),&#xA;        BatchNormalization(),&#xA;        Activation('relu'),&#xA;        MaxPooling2D(pool_size=(pool_size, pool_size)),&#xA;&#xA;        ZeroPadding2D(padding=(pad,pad)),&#xA;        Convolution2D(64, kernel, kernel, border_mode='valid'),&#xA;        BatchNormalization(),&#xA;        Activation('relu'),&#xA;    ]&#xA;    def create_decoding_layers():&#xA;    kernel = 3&#xA;    filter_size = 64&#xA;    pad = 1&#xA;    pool_size = 2&#xA;    return[&#xA;        ZeroPadding2D(padding=(pad,pad)),&#xA;        Convolution2D(64, kernel, kernel, border_mode='valid'),&#xA;        BatchNormalization(),&#xA;&#xA;        UpSampling2D(size=(pool_size,pool_size)),&#xA;        ZeroPadding2D(padding=(pad,pad)),&#xA;        Convolution2D(32, kernel, kernel, border_mode='valid'),&#xA;        BatchNormalization(),&#xA;&#xA;        UpSampling2D(size=(pool_size,pool_size)),&#xA;        ZeroPadding2D(padding=(pad,pad)),&#xA;        Convolution2D(32, kernel, kernel, border_mode='valid'),&#xA;        BatchNormalization(),&#xA;&#xA;        UpSampling2D(size=(pool_size,pool_size)),&#xA;        ZeroPadding2D(padding=(pad,pad)),&#xA;        Convolution2D(filter_size, kernel, kernel,     border_mode='valid'),&#xA;        BatchNormalization(),&#xA;        ZeroPadding2D(padding=(0,pad+1)),&#xA;    ]&#xA;&#xA;    segnet_basic = models.Sequential()&#xA;    segnet_basic.add(Layer(input_shape=(120, 420, 1)))&#xA;    segnet_basic.encoding_layers = create_encoding_layers()&#xA;    for l in segnet_basic.encoding_layers:&#xA;        segnet_basic.add(l)&#xA;    segnet_basic.decoding_layers = create_decoding_layers()&#xA;    for l in segnet_basic.decoding_layers:&#xA;        segnet_basic.add(l)&#xA;    segnet_basic.add(Convolution2D(1, 1, 1, border_mode='valid',))&#xA;    segnet_basic.summary()&#xA;    segnet_basic.add(Reshape((120,420,1)))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;На вход подается фотография и маска(область, где находится объект заполнена единицами, а остальная область нулями). Как я понимаю, на выходе мы должны получить такую же маску. Пробовал разные функции потерь. На выходе получается ерунда. Собственно вопрос: что нужно исправить, чтобы получить на выходе аналогичную маску ? Какую функцию потерь и  optimizer использовать? &#xA; На картинке пример работы уже обученной сети. image - изображение, которое подается сети, label - ожидаемый результат, который я для вывода умножил на 255, result - то, что выдает сеть.Так же умножил на 255 для вывода &#xA;&lt;a href=&quot;https://i.stack.imgur.com/uMpuN.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/uMpuN.png&quot; alt=&quot;введите сюда описание изображения&quot;&gt;&lt;/a&gt;&#xA;	python|нейронные-сети|keras	9
Найти число B такое что A*B+A+B делится на N для заданных A и N	&lt;pre&gt;&lt;code&gt;f = open(&quot;input.txt&quot;, &quot;r&quot;)&#xA;z = open(&quot;output.txt&quot;, &quot;w+&quot;)&#xA;F = f.read()&#xA;A, N = map(int, F.split())&#xA;B = 0&#xA;с = 0&#xA;for B in range(10**9):&#xA;    if (A * B + A + B) % N == 0:&#xA;        с = 1&#xA;        break&#xA;if c != 1:&#xA;    B = -1&#xA;z.write(str(B))&#xA;f.close()&#xA;z.close()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;Даются два числа. A и N. Надо найти такое B, чтобы (AB+A+B)%N=0 (сумма произведения и суммы делится на N).&lt;br&gt;&#xA;Ограничение по времени - одна секунда.&lt;br&gt;&#xA;Перебор подходит только для малых чисел.&lt;br&gt;&#xA;Если такого числа B нет, то выводим -1.&#xA;&#xA;Как быстро проверить все числа B (B не больше 10**9)?&#xA;	python|алгоритм|python-3.x	9
Ляп в Питоне: x + 1.0 &lt; x	При смешивании типов возможно &lt;a href=&quot;https://github.com/cosmologicon/pywat#mixing-numerical-types&quot; rel=&quot;noreferrer&quot;&gt;неочевидное поведение&lt;/a&gt;:&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; x = (1 &amp;lt;&amp;lt; 53) + 1&#xA;&amp;gt;&amp;gt;&amp;gt; x + 1.0 &amp;lt; x&#xA;True&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;Казалось бы, что &lt;code&gt;x + 1.0&lt;/code&gt; не меньше просто &lt;code&gt;x&lt;/code&gt;, поэтому ожидаемый результат сравнения &lt;code&gt;False&lt;/code&gt;, но возвращается &lt;code&gt;True&lt;/code&gt;. Почему?&#xA;	python	15
